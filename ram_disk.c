#include "ram_disk.h"
#include <string.h>
#include <stdio.h>

#define VIRT_DISK_BLOCK_NUM    128
#define REAL_DISK_BLOCK_NUM    8
#define DISK_BLOCK_SIZE        512
// ! Only 4 KB on memory for a 64 KB disk
//   120 sectors of 512 B are set as unwritable !

#define NSc0     (VIRT_DISK_BLOCK_NUM % 256)
#define NSc1     (VIRT_DISK_BLOCK_NUM >> 8)

uint8_t ram_disk[REAL_DISK_BLOCK_NUM][DISK_BLOCK_SIZE] = {
    //------------- Block0: Boot Sector -------------//
    // NOTE FAT12 : 
    // 0 - 2th    bytes       BS_jmpBoot
    // 3 - 10th   bytes       BS_OEMName
    // 11 - 12th  bytes       BPB_BytsPerSec  = DISK_BLOCK_SIZE (byte_per_sector)
    // 13th       byte        BPB_SecPerClus  = 1               (sector_per_cluster)
    // 14 - 15th              BPB_RsvdSecCnt  = 1               (reserved_sectors)
    // 16th                   BPB_NumFATs     = 1
    // 17 - 18th              BPB_RootEntCnt  = 16 (entries)    (fat12_root_entry_num)
    // 19 - 20th              BPB_TotSec16    = VIRT_DISK_BLOCK_NUM
    // 21th                   BPB_Media       = 0xF8            (media_type: removable media)
    // 22 - 23th              BPB_FATSz16     = 1               (sector_per_fat)  
    // 24 - 25th              BPB_SecPerTrk   = 1               (sector_per_track)
    // 26 - 27th              BPB_NumHeads    = 1
    // 28 - 31th              BPB_HiddSec     = 0               (hidden_sectors)
    // 32 - 35th              BPB_TotSec32    = 0
    // 36th                   BS_DrvNum       = 0x80            (drive_number)
    // 37th                   BS_Reserved1    = 0
    // 38th                   BS_BootSig      = 0x29            (extended_boot_signature)
    // 39 - 42th              BS_VolID        = 0x1234          (volume_serial_number)
    // 43 - 53th              BS_VolLab       = "TinyUSB MSC"
    // 54 - 61th              BS_FilSysType   = "FAT12   "
    // FAT magic code at offset 510-511 : 0xAA55
    {
        0xEB, 0x3C, 0x90, 'M' , 'S' , 'D' , 'O' , 'S' , '5' , '.' , '0' , 0x00, 0x02, 0x01, 0x01, 0x00,
        0x01, 0x10, 0x00, NSc0, NSc1, 0xF8, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x29, 0x34, 0x12, 0x00, 0x00, 'S' , 'R' , 'A' , 'M' , 'U' ,
        'S' , 'B' , ' ' , 'M' , 'S' , 'C' , 'F' , 'A' , 'T' , '1' , '2' , ' ' , ' ' , ' ' , 0x00, 0x00,

        // Zero up to 2 last bytes of FAT magic code
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA
    },

    //------------- Block1: FAT12 Table -------------//
    {
        // 0x000          cluster is free
        // 0x002 to MAX   cluster is allocated. Value of the entry is the next cluster number
        // 0xFF6          Reserved and must not be used.
        // 0xFF7          Indicates a bad (defective) cluster
        // 0xFF8 to 0xFFE Reserved and should not be used
        // 0xFFF          indicates end-of-file

        // 10 clusters per line in the following table
        0xF8, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xFF, 0xF7, 0x7F, 0xFF, //   1 ->  10
        0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, //  11 ->  20
        0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, //  21 ->  30
        0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, //  31 ->  40
        0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, //  41 ->  50
        0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, //  51 ->  60
        0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, //  61 ->  70
        0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, //  71 ->  80
        0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, //  81 ->  90
        0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, //  91 -> 100
        0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, // 101 -> 110
        0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, // 111 -> 120
        0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x7F, 0xFF, 0xF7, 0x0F, 0x00, 0x00, 0x00, 0x00, // 121 -> 127
    },

    //------------- Block2: Root Directory -------------//
    {
        /* Fields comprising each directory entry
         * 
         * 0 - 10th bytes      DIR_Name
         * 11th     byte       DIR_Attr (Readonly : 0x01, volume_id: 0x08, directory: 0x10, archive: 0x20)
         * 12th     byte       DIR_NTRes (must be 0)
         * 13th                DIR_CrtTimeTenth
         * 14 - 15th           DIR_CrtTime (Granularity is 2 seconds)
         * 16 - 17th           DIR_CrtDate
         * 18 - 19th           DIR_LstAccDate
         * 20 - 22th           DIR_FstClusHI (Only valid for volumes formatted FAT32)
         * 22 - 24th           DIR_WrtTime
         * 24 - 25th           DIR_WrtDate
         * 26 - 27th           DIR_FstClusLO
         * 28 - 31th           DIR_FileSize
         */

        // first entry is volume label
        'T' , 'i' , 'n' , 'y' , 'U' , 'S' , 'B' , ' ' , 'M' , 'S' , 'C' , 0x08, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4F, 0x6D, 0x65, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    }
};


/*-----------------------------------------------------------------------*/
/* Get Drive Status                                                      */
/*-----------------------------------------------------------------------*/
DSTATUS disk_status (
    BYTE pdrv      /* Physical drive nmuber to identify the drive */
) {
	return 0;
}


/*-----------------------------------------------------------------------*/
/* Initialize a Drive                                                    */
/*-----------------------------------------------------------------------*/
DSTATUS disk_initialize (
    BYTE pdrv      /* Physical drive nmuber to identify the drive */
) {
    return 0;
}


/*-----------------------------------------------------------------------*/
/* Read Sector(s)                                                        */
/*-----------------------------------------------------------------------*/
DRESULT disk_read (
	BYTE pdrv,      /* Physical drive nmuber to identify the drive */
	BYTE *buff,     /* Data buffer to store read data */
	LBA_t sector,   /* Start sector in LBA */
	UINT count      /* Number of sectors to read */
) {
    // out of ramdisk
    if (sector + count > VIRT_DISK_BLOCK_NUM) {
        return RES_PARERR;
    }

    for (size_t c = 0; c < count; c++) {
        if (sector + c < REAL_DISK_BLOCK_NUM) {
            memcpy(&buff[c], ram_disk[sector + c], DISK_BLOCK_SIZE);
        }
    }

    return RES_OK;
}


/*-----------------------------------------------------------------------*/
/* Write Sector(s)                                                       */
/*-----------------------------------------------------------------------*/
DRESULT disk_write (
	BYTE pdrv,			/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	LBA_t sector,		/* Start sector in LBA */
	UINT count			/* Number of sectors to write */
)
{
    // out of ramdisk
    if (sector + count > VIRT_DISK_BLOCK_NUM) {
        return RES_PARERR;
    }

    if (sector + count > REAL_DISK_BLOCK_NUM) {
        return RES_ERROR;
    }

    memcpy(ram_disk[sector], buff, count * DISK_BLOCK_SIZE);

    return RES_OK;
}


/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
/*-----------------------------------------------------------------------*/
DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
    if (cmd == GET_SECTOR_COUNT && buff) {
        LBA_t* n = buff;
        *n = VIRT_DISK_BLOCK_NUM;
    }
    else if (cmd == GET_SECTOR_SIZE && buff) {
        WORD* n = buff;
        *n = DISK_BLOCK_SIZE;
    }
    else if (cmd == GET_BLOCK_SIZE && buff) {
        DWORD* n = buff;
        *n = DISK_BLOCK_SIZE;
    }
    
    return RES_OK;
}
